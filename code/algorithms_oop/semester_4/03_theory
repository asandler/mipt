z->p
Будем вычислять префикс-функцию так же, как обычно, то есть по вычисленным значениям p[1..i] будем строить p[i+1]. Проблема заключается в
том, что нам не известна сама строка. Зато мы знаем z-функцию от строки. А по ней можно определить, совпадает ли i+1-й символ строки с
символом, следующим за наидлиннейшим префиксом. Нужно просто проверить, что z[i-p[i]+1] > p[i]. В противном случае проверять это не у p[i],
а у p[p[i]], и.т.д., то есть ровно как при вычислении префикс-функции обычным способом. Сложность построения, очевидно, не меняется.

p->z
Будем опять строить z-функцию, как обычно, динамически. Напомним, что при построении z-функции мы храним самый правый z-блок, и, в
зависимости от попадания/не_попадания i в [L, R], решаем, что делать.

Если i лежит в [L, R], то
    1) j := i - L + 1
    2) if i + z[j] <= R then
        z[i] := z[j] //(т.к. мы находимся в самом правом z-блоке)
       else
        t := i + z[j] + 1
        while (s[t] == s[t - L + 1])            (1)
            t++
        z[i + 1] := t - L
        L := i
        R := t - 1
иначе
    t := i
    while (s[t] == s[t - i + 1])                (2)
        t++
    t--
    if t > i - 1 then
        z[i + 1] := t - i + 1
        L := i
        R := t
    else
        z[i + 1] := 0

При вычислении z-функции нам требовалось проверять равенства (1) и (2). Не зная самой строки, но зная префикс-функцию, это можно сделать,
сравнив её соседние значения. Во-первых, заметим, что в случае, когда i + z[j] > R, значение префикс-функции p[i + z[j]] в точности равно j
+ z[j] (т.к. [L, R] - самый правый z-блок, а в противном случае найдется k < L такое, что k + z[k] > R, и [L, R] - не самый правый z-блок).
Тогда, p[i + z[j] + 1] == p[t] == p[i + z[j]] + 1 > p[i + z[j] + 1], если s[t] == s[j + z[j] + 1], и p[t] <= p[j + z[j] + 1] иначе.

Таким образом, цикл (1) будет продолжаться до тех пор, пока возрастает p[t]. Сложность вычисления z[i+1] в этом случае не меняется. Ничуть
не сложнее другой случай - когда i не попало в [L, R]. Проверить, что s[i+1] == s[1], можно, проверив неравенство z[p[i]] > 0, а далее
действовать так же, как в предыдущем случае - производить итерации цикла до тех пор, пока возрастает p[t]. В этом случае сложность
вычисления z[i+1] опять точно такая же.
